const assert = require('assert');
const PassThrough = require('stream').PassThrough;
const Throttled = require('..');
const readStream = require('../../readStream');

function createRandomBuffer(size) {
	const buffer = Buffer.alloc(size);
	for (let i = 0; i < size; i++) {
		buffer.writeUInt8(Math.floor(Math.random() * 256), i, true);
	}
	return buffer;
}

function *seq(from, to, step) {
	for (let time = from; time <= to; time += step) {
		yield time;
	}
}

function *powSeq(from, to, step) {
	for (let time = from; time <= to; time *= step) {
		yield Math.round(time);
	}
}

describe('ThrottledPipe', function () {

	it('should have integrity', function () {
		const data = createRandomBuffer(128);
		const stream = new PassThrough();
		process.nextTick(() => {
			stream.write(data);
			stream.end();
		});
		return readStream(
			stream.pipe(new Throttled(512))
		)
			.then((buffer) => {
				assert.equal(buffer.equals(data), true);
			});
	});

	it('should work even if input is episodic', function () {
		const data1 = createRandomBuffer(128);
		const data2 = createRandomBuffer(128);
		const stream = new PassThrough();
		process.nextTick(() => {
			stream.write(data1);
			setTimeout(function () {
				stream.write(data2);
				setTimeout(function () {
					stream.end();
				}, 300);
			}, 300);
		});
		return readStream(
			stream.pipe(new Throttled(1024))
		)
			.then((buffer) => {
				assert.equal(buffer.equals(Buffer.concat([data1, data2])), true);
			});
	});

	Array.from(powSeq(10000, 640000, 2)).forEach((dataSize) => {
		const data = createRandomBuffer(dataSize);
		Array.from(seq(150, 250, 20)).forEach((expectedTime) => {

			const interval = expectedTime / 10;
			const step = Math.ceil(dataSize / (100 / interval));

			it(`should pass ${dataSize} bytes in ${expectedTime}ms`, function () {
				const stream = new PassThrough();
				const start = Date.now();
				process.nextTick(() => {
					let pos = 0;
					function write() {
						const currentPos = pos;
						pos += step;
						if (dataSize < pos) {
							stream.write(data.slice(currentPos, dataSize));
							stream.end();
						} else {
							stream.write(data.slice(currentPos, pos));
							setTimeout(write, interval);
						}
					}
					write();
				});
				return readStream(
					stream.pipe(new Throttled(dataSize * (1000 / expectedTime)))
				)
					.then((buffer) => {
						const took = Date.now() - start;
						const d = Math.abs(expectedTime - took);
						assert.equal(buffer.equals(data), true);
						if (expectedTime * 0.3 < d) {
							throw new Error(`${expectedTime}ms was expected, but it runs for ${took}ms`);
						}
					});
			});
		});
	});

});
